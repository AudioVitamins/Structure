/* Copyright (C) 2016 Andrew Shakinovsky
*/
#include "unlockcode.h"
#include "ucshared.h"


static const unsigned char hashmap[] =
{
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF 
};



static void 
codeToElements(const unsigned char *input, int *uid, unsigned short *expire, char *prodCode, char *version)
{
   *uid = input[0] << 24;
   *uid += input[1] << 16;
   *uid += input[2] << 8;
   *uid += input[3];

   *expire = input[4] << 8;
   *expire += input[5];

   *prodCode = input[6];
   *version = input[7];
}


static bool 
hexdecode(const char *input, unsigned char *output, int len)
{
   unsigned char c;
   unsigned char v;
   for (int i = 0; i < len; i++) {
      v = hashmap[input[i * 2]];
      if (v == 0xFF)
         return false;
      c = v << 4;
      v = hashmap[input[(i * 2) + 1]];
      if (v == 0xff)
         return false;
      c += v;
      output[i] = c;
   }
   return true;
}



int 
uc_validate(const char * code, char *prodid, char *version, short int * remaining_days, int * uid)
{

   *remaining_days = 0;
   // convert to binary
   unsigned char encbuf[FULL_KEY_LEN]; // encoded buf (2nd from last 2 bytes are gen day)(last 2 are checksum)
   unsigned char decbuf[FULL_KEY_LEN]; // decoded buf (need full length because encode is also decode and adds)
   if (!hexdecode(code, encbuf, FULL_KEY_LEN))
      return 1;

   // validate checksum
   unsigned short checksum, validchecksum;
   checksum = encbuf[FULL_KEY_LEN - 2] << 8;
   checksum += encbuf[FULL_KEY_LEN - 1];
   validchecksum = getChecksum(encbuf);
   if (checksum != validchecksum)
      return UC_ERR_HEXINVALID;

   //extract gen date
   unsigned short gen_date, days_since;
   gen_date = encbuf[ENCODED_KEY_LEN-2] << 8;
   gen_date += encbuf[ENCODED_KEY_LEN - 1];

   // is this within last 90 days?
   days_since = days_since_epoch();
   if (days_since - VALID_DAYS > gen_date || gen_date > (days_since+1)) // +1 allows for timezone diff
      return UC_ERR_TIMECODEINVALID; // time code is invalid or expired. will not unencrypt

   

   // decode
   encode(encbuf, gen_date, decbuf);

   // look at elements
   unsigned short expire_day;
   codeToElements(decbuf, uid, &expire_day, prodid, version);

   // is date still valid
   *remaining_days = expire_day - days_since;

   if (*remaining_days <= 0 ||  // is in the past
      *remaining_days > (VALID_DAYS+1)) // is more than valid days into the future (add one for timezone issues)
      return UC_ERR_EXPIRED;

   // validate uid (dont remove check digit as it's part of uid)
   if (!luhnvalid(*uid))
      return UC_ERR_UIDINVALID;


   return 0;
}
